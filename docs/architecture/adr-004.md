---
last_edited: 2026-02-19
editor: Claude Code (Claude Opus 4.6)
user: Coldaine
status: ready
version: 1.0.0
subsystem: monorepo
tags: [adr, hooks, claude-code, development-harness, orchestration]
doc_type: adr
---

# ADR-004: Hooks-as-Primitives Development Harness

## Status
**Accepted** (2026-02-19)

## Context

Recall Pipeline uses Claude Code on the web as its primary development environment. We already have basic lifecycle hooks in place: a `SessionStart` hook that prints a morning checklist and outputs a JSON status object, and a `SessionEnd` hook that runs a compliance check banner. These hooks live in `.claude/hooks/` and are wired through `.claude/settings.json`. Alongside them, we have skills (`.claude/skills/`) that encode development workflows like `/morning`, `/next-task`, and `/implement`.

Through building and using these hooks, a key architectural insight emerged:

**Hooks are the universal primitive for development automation.**

Claude Code exposes lifecycle events -- `SessionStart`, `SessionEnd`, `Stop`, `PreToolUse`, `PostToolUse` -- each of which can trigger arbitrary shell commands. This means any orchestration pattern that requires "run code at a specific point in the development lifecycle" can be expressed as a hook. Multi-agent workflows, CI gate enforcement, automatic context loading, compliance verification, progress tracking, destructive-operation guards -- all of these reduce to: *which lifecycle event, what code to run, what state to read/write*.

The user previously built **claude-flow**, an external orchestration system for Claude Code. In retrospect, claude-flow is essentially hooks plus external state management. The same patterns can be achieved with repo-local hooks and a shared persistence layer (PostgreSQL, Redis, or filesystem), without any external orchestration binary.

This insight has practical consequences: rather than building a separate orchestration tool and then applying it to projects, we should build the orchestration *inside* a real project using hooks as the foundational building block, iterating on the harness while simultaneously delivering real features.

## Decision

We adopt a **hooks-as-primitives** approach where Claude Code lifecycle hooks are the foundational building block for all development automation in this repository.

Specifically:

1. **Hooks are the orchestration layer.** Every development automation concern -- context loading, task assignment, compliance checking, CI gates, progress tracking -- is implemented as a hook attached to the appropriate lifecycle event. No external orchestration binary is required.

2. **Recall Pipeline is the test bed.** We use this project to develop real features (capture, storage, agents) while simultaneously iterating on the hooks harness. The harness improves because we encounter real pain points; the project benefits because the harness enforces quality. This is deliberate dogfooding.

3. **The harness lives alongside the project, not instead of it.** Hook scripts live in `.claude/hooks/`, skills in `.claude/skills/`, and harness documentation in `docs/dev/`. The harness does NOT replace the project's codebase, build system, or architecture. It is a development-time concern that augments the existing workflow.

4. **We extend beyond SessionStart/SessionEnd.** The current hooks cover session boundaries only. We will progressively adopt `Stop`, `PreToolUse`, and `PostToolUse` hooks to cover the full development lifecycle, following the phased plan described below.

5. **Cross-session state uses external persistence.** Hooks are stateless by default (each invocation is a fresh shell). Any state that must persist across sessions or hook invocations (task progress, session logs, compliance history) is stored in PostgreSQL or the filesystem -- never in ephemeral shell variables.

## Hook Primitives Available

Claude Code exposes the following lifecycle events, each of which can trigger one or more shell commands with a 60-second execution timeout:

| Hook Event | Fires When | Use Cases |
|---|---|---|
| **SessionStart** | Claude Code session begins or resumes | Load project context, print checklists, set environment variables, query memory for past decisions |
| **Stop** | Claude finishes generating a response | Trigger follow-up actions, auto-archive completed work, update progress trackers, chain next steps |
| **PreToolUse** | Before a tool call executes (e.g., Bash, Write, Edit) | Gate destructive operations, enforce naming conventions, require confirmation for risky commands, block commits to protected branches |
| **PostToolUse** | After a tool call completes | Auto-run tests after file edits, notify on commit, update documentation indexes, log tool usage patterns |
| **SessionEnd** | Session terminates | Cleanup, compliance summary, session report (note: unreliable in web context -- may not fire) |

Each hook entry in `.claude/settings.json` supports a `matcher` field (regex against event metadata) and can run any executable. Hooks receive context via environment variables (`$CLAUDE_PROJECT_DIR`, `$CLAUDE_CODE_REMOTE`, etc.) and can output JSON to communicate back to Claude.

## Consequences

### Positive

- **Zero external dependencies for orchestration.** Everything lives in the repository under `.claude/`. No separate binary, no daemon, no external service. Clone the repo and the harness comes with it.
- **Dogfooding drives quality.** By using the harness to build real features on Recall Pipeline, we discover pain points, timeout issues, and missing capabilities that would be invisible in a synthetic test environment.
- **Portable across projects.** Any project can adopt the hooks-as-primitives pattern by copying the `.claude/` directory structure and adapting the scripts. The pattern is not specific to Recall Pipeline.
- **Incremental adoption.** Each hook is independent. A project can start with `SessionStart` context loading and add `PreToolUse` gates months later. There is no all-or-nothing commitment.
- **Composable.** Hooks are just shell scripts. They can call other scripts, query databases, invoke APIs, or spawn sub-processes. Complex workflows compose from simple primitives.

### Negative

- **SessionEnd reliability in web context is unclear.** When using Claude Code on the web, the `SessionEnd` hook may not fire if the browser tab is closed or the connection drops. Any critical cleanup logic must not depend solely on `SessionEnd`; it should have a fallback (e.g., `SessionStart` detecting incomplete previous sessions).
- **60-second hook timeout limits synchronous operations.** Hooks must complete within 60 seconds. Long-running operations (full test suites, large builds) cannot run synchronously in a hook. They must be kicked off asynchronously or limited to fast checks.
- **External state required for cross-session persistence.** Hooks cannot share in-memory state. Any workflow that spans multiple sessions (multi-day task tracking, cumulative compliance scoring) requires writing to PostgreSQL, Redis, or the filesystem.
- **Debugging hook failures is opaque.** When a hook fails silently or produces unexpected output, diagnosing the issue requires manual inspection of the hook script, its environment, and its exit code. There is no built-in hook debugger.
- **Matcher regex complexity.** As the number of hooks grows, the `matcher` field regex patterns can become difficult to maintain. A clear naming and documentation convention is essential.

## Test Bed Plan

We adopt a phased rollout, using Recall Pipeline development as the proving ground for each phase.

### Phase 1: Session Boundaries (Current)

**Status**: Implemented.

- **SessionStart**: Morning workflow checklist, context loading prompt, JSON status output.
- **SessionEnd**: Compliance check banner, session summary prompt.
- **Skills**: `/morning`, `/next-task`, `/implement` encode development workflows as structured markdown.
- **Artifacts**: `.claude/hooks/session-start.sh`, `.claude/hooks/session-end.sh`, `.claude/settings.json`.

**Learnings so far**: SessionStart is highly reliable and sets the tone for the entire session. SessionEnd fires inconsistently in web contexts; critical logic should not depend on it alone.

### Phase 2: Stop Hook -- Response-Level Automation

**Goal**: React to each Claude response completion to maintain continuity and track progress.

- Auto-archive completed task output to a session log.
- Update progress indicators (e.g., append to a `session-progress.jsonl` file).
- Detect when a task is complete and prompt for the next one.
- Chain multi-step workflows: when one step finishes, the Stop hook can suggest or trigger the next.

**Risk**: The Stop hook fires frequently. Scripts must be fast (well under 60 seconds) and idempotent.

### Phase 3: PreToolUse Gates -- Safety and Compliance

**Goal**: Intercept tool calls before execution to enforce safety and compliance rules.

- **Git safety**: Block `git push --force` to `main`/`master`, `git reset --hard`, `git clean -f`, and other destructive operations unless explicitly confirmed.
- **File protection**: Prevent writes to `.env`, `credentials.json`, or other sensitive files without explicit confirmation.
- **Naming enforcement**: Reject file creation under `docs/domains/` that does not follow the domain code prefix convention (currently enforced post-hoc by CI; can be enforced pre-emptively).
- **Architecture compliance**: Block creation of SQLite files or imports of SQLite libraries (Northstar principle enforcement at the tool level).

**Risk**: Overly aggressive gating will slow down development and create friction. Gates should be surgical: block only genuinely dangerous operations, not routine ones.

### Phase 4: PostToolUse Reactions -- Feedback Loops

**Goal**: React to tool results to create automated feedback loops.

- **Auto-test after file edits**: When a `.rs` file under `capture/` is edited, automatically run `cargo check --workspace` and report errors inline.
- **Auto-lint after documentation edits**: When a `.md` file under `docs/` is edited, verify frontmatter compliance and `docs/index.md` linkage.
- **Commit annotation**: After a `git commit`, automatically verify the commit message format and tag compliance.
- **Notification**: After a `git push`, notify via webhook or log that code was pushed.

**Risk**: PostToolUse reactions that trigger further tool calls can create feedback loops. Reactions must be read-only or carefully guarded against re-triggering.

## Relationship to claude-flow

This ADR does not deprecate or replace claude-flow. The two serve different purposes:

- **claude-flow**: External orchestration for multi-agent workflows across multiple Claude Code instances. Useful when you need parallel agents working on different parts of a codebase simultaneously.
- **Hooks-as-primitives**: Repo-local development automation for a single Claude Code session. Useful for enforcing workflows, loading context, gating operations, and creating feedback loops within one session.

The insight is that many patterns previously assumed to require claude-flow (context loading, compliance checking, workflow enforcement) can be achieved with hooks alone. claude-flow remains valuable for the subset of patterns that genuinely require cross-instance coordination.

## References

- `.claude/settings.json` -- Hook configuration
- `.claude/hooks/session-start.sh` -- Phase 1 SessionStart implementation
- `.claude/hooks/session-end.sh` -- Phase 1 SessionEnd implementation
- `.claude/skills/` -- Skill definitions (morning.md, next-task.md, implement.md)
- [ADR-001: PostgreSQL Only](adr-001.md) -- Storage decision (relevant to cross-session state)
- [ADR-002: Pure Rust Stack](adr-002.md) -- Language decision (relevant to hook script language choices)
- [Northstar Principles](../Northstar.md) -- Immutable project principles enforced by hooks
