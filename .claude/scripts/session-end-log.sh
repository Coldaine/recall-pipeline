#!/bin/bash
# Session end hook - generates rich session log using LLM
# Called automatically when Claude Code session ends
# Uses Goose -> Kilo Code -> CCR (in order of preference)

set -e

# Read JSON input from stdin
INPUT=$(cat)

# Extract fields
SESSION_ID=$(echo "$INPUT" | grep -o '"session_id":"[^"]*"' | cut -d'"' -f4)
TRANSCRIPT_PATH=$(echo "$INPUT" | grep -o '"transcript_path":"[^"]*"' | cut -d'"' -f4)
REASON=$(echo "$INPUT" | grep -o '"reason":"[^"]*"' | cut -d'"' -f4)
CWD=$(echo "$INPUT" | grep -o '"cwd":"[^"]*"' | cut -d'"' -f4)

# Only log if we're in the recall-pipeline project
if [[ "$CWD" != *"recall-pipeline"* ]]; then
    exit 0
fi

# Create log directory if needed
LOG_DIR="$CWD/docs/session-logs"
mkdir -p "$LOG_DIR"

# Generate filename
DATE=$(date +%Y-%m-%d)
TIME=$(date +%H%M)
LOG_FILE="$LOG_DIR/${DATE}-session-${TIME}.md"

# Source environment for API keys
if [[ -f ~/.bashrc ]]; then
    source ~/.bashrc 2>/dev/null || true
fi

# Try to extract recent context from transcript (last 50 lines of content)
CONTEXT=""
if [[ -f "$TRANSCRIPT_PATH" ]]; then
    # Extract assistant messages from JSONL transcript
    CONTEXT=$(tail -100 "$TRANSCRIPT_PATH" 2>/dev/null | grep -o '"content":"[^"]*"' | tail -20 | cut -d'"' -f4 | tr '\n' ' ' | head -c 2000)
fi

# Build the prompt for session summarization
PROMPT="You are a session logger. Based on the following context from a coding session, write a brief markdown session log.

Session ID: $SESSION_ID
End Reason: $REASON
Date: $(date -Iseconds)

Context snippets: $CONTEXT

Write a session log with these sections:
## Summary (2-3 sentences)
## Work Completed (bullet points)
## Decisions Made (if any)
## Next Steps (if apparent)

Keep it concise. If context is limited, note that this is an auto-generated metadata log."

# Function to generate summary with Goose
try_goose() {
    if command -v goose &> /dev/null; then
        echo "Using Goose for session summary..." >&2
        SUMMARY=$(OPENAI_API_KEY="${OPENAI_API_KEY:-$ZAI_API_KEY}" \
            OPENAI_HOST="${OPENAI_HOST:-https://api.z.ai}" \
            OPENAI_BASE_PATH="${OPENAI_BASE_PATH:-api/coding/paas/v4/chat/completions}" \
            goose run --provider openai --model glm-4.6 --quiet --no-session -t "$PROMPT" 2>/dev/null)
        if [[ -n "$SUMMARY" ]]; then
            echo "$SUMMARY"
            return 0
        fi
    fi
    return 1
}

# Function to generate summary with Kilo Code CLI
try_kilocode() {
    if command -v kilocode &> /dev/null && command -v jq &> /dev/null; then
        echo "Using Kilo Code for session summary..." >&2
        RESPONSE=$(kilocode --auto --json --timeout 60 --mode ask "$PROMPT" 2>/dev/null | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g')
        # Get the final completion_result (partial:false) with content
        SUMMARY=$(echo "$RESPONSE" | grep '"say":"completion_result"' | grep '"partial":false' | jq -r '.content // empty')
        if [[ -n "$SUMMARY" ]]; then
            echo "$SUMMARY"
            return 0
        fi
    fi
    return 1
}

# Function to generate summary with CCR (Claude Code Router)
try_ccr() {
    if curl -s "http://127.0.0.1:3456/health" &>/dev/null; then
        echo "Using CCR for session summary..." >&2
        RESPONSE=$(curl -s -X POST "http://127.0.0.1:3456/v1/messages" \
            -H "Content-Type: application/json" \
            -H "anthropic-version: 2023-06-01" \
            -H "x-api-key: session-log" \
            -d "{
                \"model\": \"session-log\",
                \"messages\": [{\"role\": \"user\", \"content\": $(echo "$PROMPT" | jq -Rs .)}],
                \"max_tokens\": 500
            }" 2>/dev/null)

        SUMMARY=$(echo "$RESPONSE" | grep -o '"text":"[^"]*"' | head -1 | cut -d'"' -f4 | sed 's/\\n/\n/g')
        if [[ -n "$SUMMARY" ]]; then
            echo "$SUMMARY"
            return 0
        fi
    fi
    return 1
}

# Try each method in order of preference
GENERATED_SUMMARY=""
if GENERATED_SUMMARY=$(try_goose); then
    :
elif GENERATED_SUMMARY=$(try_kilocode); then
    :
elif GENERATED_SUMMARY=$(try_ccr); then
    :
else
    # Fallback to basic metadata log
    GENERATED_SUMMARY="## Summary
Auto-generated session metadata (no LLM available for rich summary).

## Session Info
- Session ended: $(date -Iseconds)
- Reason: $REASON

## Notes
Use \`/session-log\` before ending for detailed summaries."
fi

# Write the final log file
cat > "$LOG_FILE" << EOF
# Session Log: $DATE

$GENERATED_SUMMARY

---

## Metadata
- **Session ID**: \`$SESSION_ID\`
- **End Reason**: $REASON
- **Timestamp**: $(date -Iseconds)
- **Transcript**: \`$TRANSCRIPT_PATH\`

---
*Auto-generated by session-end hook*
EOF

echo "Session logged to: $LOG_FILE" >&2
